

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Ember.js - Understanding Ember.js</title>
    <link rel="shortcut icon" href="/images/favicon.png" />
    <link href="/stylesheets/site.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/highlight.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/emberjs-cn.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="http://emberjs.cn/blog/feed.xml" rel="alternate" type="application/atom+xml" title="Ember.js CN - 博客" />

    <script type="text/javascript">
      var _gaq = _gaq || [];
      var pluginUrl = '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
      _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
      _gaq.push(['_setAccount', 'UA-38578402-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>

    <script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="/javascripts/jquery.bxSlider.min.js"></script>

    <script type="text/javascript">
      $(function() {
        var backToTop = $('#back-to-top');
        var doc = $(document);
        var offset = backToTop.offset();
        var marginTop = 90;
        var showing = false;

        positionBackToTop = function(reset) {
          if (reset) {
            backToTop.css({
              top: '',
              position: ''
            });
            offset = backToTop.offset();
          }

          if (!showing && doc.scrollTop() > offset.top+200) {
            showing = true;
            backToTop.css({
              position: 'fixed',
              top: 20,
              left: offset.left,
              display:' block'
            });
          } else if (showing && doc.scrollTop() <= offset.top+200) {
            showing = false;
            backToTop.css({
              display:'none'
            });
          }
        };

        if (backToTop.length) {
          backToTop.on('click', function(evt) {
            $('html,body').animate({scrollTop: 0}, 200);
            return false;
          });

          doc.on('scroll', function() {
            positionBackToTop();
          });
        }

        $('.bx-wrapper, .bx-window').width(940);
      });
    </script>

    
  </head>

  <body class="bilingual_guides bilingual_guides_understanding-ember bilingual_guides_understanding-ember_the-view-layer bilingual_guides_understanding-ember_the-view-layer_index">
    <div id="header">
      <div id="wrapper">
        <a id="logo" href="/">&nbsp;</a>
        <ul id="nav">
          <li><a href="/blog">博客</a></li>
          <li><a href="/guides">指南</a></li>
          <li>
            <a target="_blank" href="http://discuss.emberjs.cn">论坛</a>
          </li>
        </ul>
        <div id="github">
          <a href="https://github.com/emberjs-cn"><img src="/images/fork-us.png">Fork Us!</a>
          <a href="https://github.com/emberjs/ember.js"><img src="/images/fork-us.png">Fork Ember!</a>
        </div>
      </div>
    </div>

    <div id="content-wrapper">
      
      
        <div id="sidebar">
          
    <ol id="toc-list">
          <li class="level-1">
            <a href="/bilingual_guides/concepts/core-concepts">概念</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/concepts/core-concepts">核心概念</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/concepts/naming-conventions">命名惯例</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/application">应用</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/application">介绍</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/application/the-application-template">应用模板</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/templates/handlebars-basics">模板</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/templates/handlebars-basics">Handlebars基础</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/conditionals">条件表达式</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/displaying-a-list-of-items">显示项目列表</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/changing-scope">切换作用域</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/binding-element-attributes">绑定元素属性</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/binding-element-class-names">绑定元素类名称</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/links">链接</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/actions">操作</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/rendering-with-helpers">Rendering with Helpers</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/templates/writing-helpers">Writing Helpers</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/routing">路由</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/routing">介绍</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/defining-your-routes">定义路由</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/generated-objects">生成的对象</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/specifying-a-routes-model">指定路由的模型</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/setting-up-a-controller">设置控制器</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/rendering-a-template">渲染模板</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/redirection">重定向</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/routing/specifying-the-location-api">指定地址API</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/controllers">控制器</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/controllers">介绍</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/controllers/representing-a-single-model-with-objectcontroller">代表单一模型</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/controllers/representing-multiple-models-with-arraycontroller">代表多模型</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/controllers/dependencies-between-controllers">管理控制器间的依赖</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/models">模型</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/models">介绍</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/defining-a-store">创建一个存储器</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/defining-models">定义模型</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/finding-models">查找模型</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/modifying-attributes">修改属性</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/model-lifecycle">Model Lifecycle</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/models/the-rest-adapter">The REST Adapter</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/views">视图</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/views">介绍</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/views/defining-a-view">定义视图</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/views/handling-events">处理事件</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/views/inserting-views-in-templates">在模板中插入视图</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/views/adding-layouts-to-views">Adding Layouts to Views</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/views/customizing-a-views-element">Customizing a View's Element</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/views/built-in-views">Built-in Views</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/views/manually-managing-view-hierarchy">Manually Managing View Hierarchy</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/object-model/classes-and-instances">对象模型</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/object-model/classes-and-instances">类与实例</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/object-model/computed-properties">Computed Properties</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/object-model/computed-properties-and-aggregate-data">Computed Properties and Aggregate Data with @each</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/object-model/observers">Observers</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/object-model/bindings">Bindings</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/object-model/reopening-classes-and-instances">Reopening Classes and Instances</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/object-model/what-do-i-use-when">Bindings, Observers, Computed Properties: What Do I Use When?</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/enumerables">Enumerables</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/enumerables">Introduction</a>
            </li>
          </ol></li>
          <li class="level-1">
            <a href="/bilingual_guides/configuring-ember/disabling-prototype-extensions">Configuring Ember.js</a>
            <ol>
        
            <li class="level-3">
              <a href="/bilingual_guides/configuring-ember/disabling-prototype-extensions">Disabling Prototype Extensions</a>
            </li>
          </ol></li>
          <li class="level-1 selected">
            <a href="/bilingual_guides/understanding-ember/the-view-layer">Understanding Ember.js</a>
            <ol class='selected'>
        
            <li class="level-3 sub-selected">
              <a href="/bilingual_guides/understanding-ember/the-view-layer">The View Layer</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/understanding-ember/managing-asynchrony">Managing Asynchrony</a>
            </li>
          
            <li class="level-3">
              <a href="/bilingual_guides/understanding-ember/keeping-templates-up-to-date">Keeping Templates Up-to-Date</a>
            </li>
          </ol></li></ol>
  
          <div id="back-to-top"><a id="back-top-top" href="#">&#11014; 返回顶部</a></div>
        </div>
      
      <div id="content" class="has-sidebar">
          

  <div class="chapter">
    <h1>Understanding Ember.js</h1>
    <h2 class='anchorable-toc' id='toc_the-ember-js-view-layer'>The Ember.js View Layer</h2>
<p>This guide goes into extreme detail about the Ember.js view layer. It is
intended for an experienced Ember developer, and includes details that
are unnecessary for getting started with Ember.</p>

<p>Ember.js has a sophisticated system for creating, managing and rendering a hierarchy of views that connect to the browser&#39;s DOM. Views are responsible for responding to user events, like clicks, drags, and scrolls, as well as updating the contents of the DOM when the data underlying the view changes.</p>

<p>View hierarchies are usually created by evaluating a Handlebars template. As the template is evaluated, child views are added. As the templates for <em>those</em> child views are evaluated, they may have child views added, and so on, until an entire hierarchy is created.</p>

<p>Even if you do not explicitly create child views from your Handlebars templates, Ember.js internally uses the view system to update bound values. For example, every Handlebars expression <code>{{value}}</code> creates a view behind-the-scenes that knows how to update the bound value if it changes.</p>

<p>You can also dynamically make changes to the view hierarchy at application runtime using the <code>Ember.ContainerView</code> class. Rather than being template-driven, a container view exposes an array of child view instances that can be manually managed.</p>

<p>Views and templates work in tandem to provide a robust system for creating whatever user interface you dream up. End users should be isolated from the complexities of things like timing issues while rendering and event propagation. Application developers should be able to describe their UI once, as a string of Handlebars markup, and then carry on with their application without having to worry about making sure that it remains up-to-date.</p>
<h3 class='anchorable-toc' id='toc_what-problems-does-it-solve'>What problems does it solve?</h3><h4 class='anchorable-toc' id='toc_child-views'>Child Views</h4>
<p>In a typical client-side application, views may represent elements nested inside of each other in the DOM. In the naïve solution to this problem, separate view objects represent each DOM element, and ad-hoc references help the various view object keep track of the views conceptually nested inside of them.</p>

<p>Here is a simple example, representing one main app view, a collection nested inside of it, and individual items nested inside of the collection.</p>

<figure>
  <img src="/images/view-guide/view-hierarchy-simple.png">
</figure>

<p>This system works well at first glance, but imagine that we want to open Joe&#39;s Lamprey Shack at 8am instead of 9am. In this situation, we will want to re-render the App View. Because the developer needed to build up the references to the children on an ad-hoc basis, this re-rendering process has several problems.</p>

<p>In order to re-render the App View, the App View must also manually re-render the child views and re-insert them into App View&#39;s element. If implemented perfectly, this process works well, but it relies upon a perfect, ad hoc implementation of a view hierarchy. If any single view fails to implement this precisely, the entire re-render will fail.</p>

<p>In order to avoid these problems, Ember&#39;s view hierarchy has the concept of child views baked in.</p>

<figure>
  <img src="/images/view-guide/view-hierarchy-ember.png">
</figure>

<p>When the App View re-renders, Ember is responsible for re-rendering and inserting the child views, not application code. This also means that Ember can perform any memory management for you, such as cleaning up observers and bindings.</p>

<p>Not only does this eliminate quite a bit of boilerplate code, but it eliminates the possibility that an imperfectly implemented view hierarchy will cause unexpected failures.</p>
<h4 class='anchorable-toc' id='toc_event-delegation'>Event Delegation</h4>
<p>In the past, web developers have added event listeners to individual elements in order to know when the user interacts with them. For example, you might have a <code>&lt;div&gt;</code> element on which you register a function that gets called when the user clicks it.</p>

<p>However, this approach often does not scale when dealing with large numbers of interactive elements. For example, imagine a <code>&lt;ul&gt;</code> with 100 <code>&lt;li&gt;</code>s in it, with a delete button next to each item. Since the behavior is the same for all of these items, it would be inefficient to create 100 event listeners, one for each delete button.</p>

<figure>
  <img src="/images/view-guide/undelegated.png">
</figure>

<p>To solve this problem, developers discovered a technique called &quot;event delegation&quot;. Instead of registering a listener on each element in question, you can register a single listener for the containing element and use <code>event.target</code> to identify which element the user clicked on.</p>

<figure>
  <img src="/images/view-guide/delegated.png">
</figure>

<p>Implementing this is a bit tricky, because some events (like <code>focus</code>, <code>blur</code> and <code>change</code>) don&#39;t bubble. Fortunately, jQuery has solved this problem thoroughly; using jQuery&#39;s <code>on</code> method reliably works for all native browser events.</p>

<p>Other JavaScript frameworks tackle this problem in one of two ways. In the first approach, they ask you to implement the naïve solution yourself, creating a separate view for each element. When you create the view, it sets up an event listener on the view&#39;s element. If you had a list of 500 items, you would create 500 views and each would set up a listener on its own element.</p>

<p>In the second approach, the framework builds in event delegation at the view level. When creating a view, you can supply a list of events to delegate and a method to call when the event occurs. This leaves identifying the context of the click (for example, which item in the list) to the method receiving the event.</p>

<p>You are now faced with an uncomfortable choice: create a new view for each item and lose the benefits of event delegation, or create a single view for all of the items and have to store information about the underlying JavaScript object in the DOM.</p>

<p>In order to solve this problem, Ember delegates all events to the application&#39;s root element (usually the document <code>body</code>) using jQuery. When an event occurs, Ember identifies the nearest view that handles the event and invokes its event handler. This means that you can create views to hold a JavaScript context, but still get the benefit of event delegation.</p>

<p>Further, because Ember registers only one event for the entire Ember application, creating new views never requires setting up event listeners, making re-renders efficient and less error-prone. When a view has child views, this also means that there is no need to manually undelegate views that the re-render process replaces.</p>
<h4 class='anchorable-toc' id='toc_the-rendering-pipeline'>The Rendering Pipeline</h4>
<p>Most web applications specify their user interface using the markup of a particular templating language. For Ember.js, we&#39;ve done the work to make templates written using the Handlebars templating language automatically update when the values used inside of them are changed.</p>

<p>While the process of displaying a template is automatic for developers, under the hood there are a series of steps that must be taken to go from the original template to the final, live DOM representation that the user sees.</p>

<p>This is the approximate lifecycle of an Ember view:</p>

<figure>
  <img src="/images/view-guide/view-lifecycle-ember.png">
</figure>
<h5 class='anchorable-toc' id='toc_1-template-compilation'>1. Template Compilation</h5>
<p>The application&#39;s templates are loaded over the network or as part of the application payload in string form. When the application loads, it sends the template string to Handlebars to be compiled into a function. Once compiled, the template function is saved, and can be used by multiple views repeatedly, each time they need to re-render.</p>

<p>This step may be omitted in applications where the templates are pre-compiled on the server. In those cases, the template is transferred not as the original, human-readable template string but as the compiled code.</p>

<p>Because Ember is responsible for template compilation, you don&#39;t have to do any additional work to ensure that compiled templates are reused.</p>
<h5 class='anchorable-toc' id='toc_2-string-concatenation'>2. String Concatenation</h5>
<p>A view&#39;s rendering process is kickstarted when the application calls <code>append</code> or <code>appendTo</code> on the view. Calling <code>append</code> or <code>appendTo</code> <strong>schedules</strong> the view to be rendered and inserted later. This allows any deferred logic in your application (such as binding synchronization) to happen before rendering the element.</p>

<p>To begin the rendering process, Ember creates a <code>RenderBuffer</code> and gives it to the view to append its contents to. During this process, a view can create and render child views. When it does so, the parent view creates and assigns a <code>RenderBuffer</code> for the child, and links it to the parent&#39;s <code>RenderBuffer</code>.</p>

<p>Ember flushes the binding synchronization queue before rendering each view. By syncing bindings before rendering each view, Ember guarantees that it will not render stale data it needs to replace right away.</p>

<p>Once the main view has finished rendering, the render process has created a tree of views (the &quot;view hierarchy&quot;), linked to a tree of buffers. By walking down the tree of buffers and converting them into Strings, we have a String that we can insert into the DOM.</p>

<p>Here is a simple example:</p>

<figure>
  <img src="/images/view-guide/render-buffer.png">
</figure>

<p>In addition to children (Strings and other <code>RenderBuffer</code>s), a <code>RenderBuffer</code> also encapsulates the element&#39;s tag name, id, classes, style, and other attributes. This makes it possible for the render process to modify one of these properties (style, for example), even after its child Strings have rendered. Because many of these properties are controlled via bindings (e.g. using <code>bindAttr</code>), this makes the process robust and transparent.</p>
<h5 class='anchorable-toc' id='toc_3-element-creation-and-insertion'>3. Element Creation and Insertion</h5>
<p>At the end of the rendering process, the root view asks the <code>RenderBuffer</code> for its element. The <code>RenderBuffer</code> takes its completed string and uses jQuery to convert it into an element. The view assigns that element to its <code>element</code> property and places it into the correct place in the DOM (the location specified in <code>appendTo</code> or the application&#39;s root element if the application used <code>append</code>).</p>

<p>While the parent view assigns its element directly, each child views looks up its element lazily. It does this by looking for an element whose <code>id</code> matches its <code>elementId</code> property. Unless explicitly provided, the rendering process generates an <code>elementId</code> property and assigns its value to the view&#39;s <code>RenderBuffer</code>, which allows the view to find its element as needed.</p>
<h5 class='anchorable-toc' id='toc_4-re-rendering'>4. Re-Rendering</h5>
<p>After the view inserts itself into the DOM, either Ember or the application may want to re-render the view. They can trigger a re-render by calling the <code>rerender</code> method on a view.</p>

<p>Rerendering will repeat steps 2 and 3 above, with two exceptions:</p>

<ul>
<li>Instead of inserting the element into an explicitly specified location, <code>rerender</code> replaces the existing element with the new element.</li>
<li>In addition to rendering a new element, it also removes the old element and destroys its children. This allows Ember to automatically handle unregistering appropriate bindings and observers when re-rendering a view. This makes observers on a path more viable, because the process of registering and unregistering all of the nested observers is automatic.</li>
</ul>

<p>The most common cause of a view re-render is when the value bound to a Handlebars expression (<code>{{foo}}</code>) changes. Internally, Ember creates a simple view for each expression, and registers an observer on the path. When the path changes, Ember updates the area of the DOM with the new value.</p>

<p>Another common case is an <code>{{#if}}</code> or <code>{{#with}}</code> block. When rendering a template, Ember creates a virtual view for these block helpers. These virtual views do not appear in the publicly available view hierarchy (when getting <code>parentView</code> and <code>childViews</code> from a view), but they exist to enable consistent re-rendering.</p>

<p>When the path passed to an <code>{{#if}}</code> or <code>{{#with}}</code> changes, Ember automatically re-renders the virtual view, which will replace its contents, and importantly, destroy all child views to free up their memory.</p>

<p>In addition to these cases, the application may sometimes want to explicitly re-render a view (usually a <code>ContainerView</code>, see below). In this case, the application can call <code>rerender</code> directly, and Ember will queue up a re-rendering job, with the same semantics.</p>

<p>The process looks something like:</p>

<figure>
  <img src="/images/view-guide/re-render.png">
</figure>
<h3 class='anchorable-toc' id='toc_the-view-hierarchy'>The View Hierarchy</h3><h4 class='anchorable-toc' id='toc_parent-and-child-views'>Parent and Child Views</h4>
<p>As Ember renders a templated view, it will generate a view hierarchy. Let&#39;s assume we have a template <code>form</code>.</p>
<div class="highlight handlebars "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="inline"><span class="inline-delimiter">{{</span><span class="attribute-name">view</span> <span class="attribute-name">App.Search</span> <span class="attribute-name">placeholder</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Search</span><span class="delimiter">&quot;</span></span><span class="inline-delimiter">}}</span></span>
<span class="inline"><span class="inline-delimiter">{{#</span><span class="attribute-name">view</span> <span class="attribute-name">Ember.Button</span><span class="inline-delimiter">}}</span></span>Go!<span class="inline"><span class="inline-delimiter">{{/</span><span class="attribute-name">view</span><span class="inline-delimiter">}}</span></span>
</pre></td>
</tr></table>
</div></div>
<p>And we insert it into the DOM like this:</p>
<div class="highlight javascript "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> view = Ember.View.create({
  <span class="key">templateName</span>: <span class="string"><span class="delimiter">'</span><span class="content">form</span><span class="delimiter">'</span></span>
}).append();
</pre></td>
</tr></table>
</div></div>
<p>This will create a small view hierarchy that looks like this:</p>

<figure>
  <img src="/images/view-guide/simple-view-hierarchy.png">
</figure>

<p>You can move around in the view hierarchy using the <code>parentView</code> and <code>childViews</code> properties.</p>
<div class="highlight javascript "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> children = view.get(<span class="string"><span class="delimiter">'</span><span class="content">childViews</span><span class="delimiter">'</span></span>) <span class="comment">// [ &lt;App.Search&gt;, &lt;Ember.Button&gt; ]</span>
children.objectAt(<span class="integer">0</span>).get(<span class="string"><span class="delimiter">'</span><span class="content">parentView</span><span class="delimiter">'</span></span>) <span class="comment">// view</span>
</pre></td>
</tr></table>
</div></div>
<p>One common use of the <code>parentView</code> method is inside of an instance of a child view.</p>
<div class="highlight javascript "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre>App.Search = Ember.View.extend({
  <span class="function">didInsertElement</span>: <span class="keyword">function</span>() {
    <span class="comment">// this.get('parentView') in here references `view`</span>
  }
})
</pre></td>
</tr></table>
</div></div><h4 class='anchorable-toc' id='toc_lifecycle-hooks'>Lifecycle Hooks</h4>
<p>In order to make it easy to take action at different points during your view&#39;s lifecycle, there are several hooks you can implement.</p>

<ul>
<li><code>willInsertElement</code>: This hook is called after the view has been rendered but before it has been inserted into the DOM. It does not provide access to the view&#39;s <code>element</code>.</li>
<li><code>didInsertElement</code>: This hook is called immediately after the view has been inserted into the DOM. It provides access to the view&#39;s <code>element</code> and is most useful for integration with an external library. Any explicit DOM setup code should be limited to this hook.</li>
<li><code>willDestroyElement</code>: This hook is called immediately before the element is removed from the DOM. This is your opportunity to tear down any external state associated with the DOM node. Like <code>didInsertElement</code>, it is most useful for integration with external libraries.</li>
<li><code>willRerender</code>: This hook is called immediately before a view is re-rendered. This is useful if you want to perform some teardown immediately before a view is re-rendered.</li>
<li><code>becameVisible</code>: This hook is called after a view&#39;s <code>isVisible</code> property, or one of its ancestor&#39;s <code>isVisible</code> property, changes to true and the associated element becomes visible. Note that this hook is only reliable if all visibility is routed through the <code>isVisible</code> property.</li>
<li><code>becameHidden</code>: This hook is called after a view&#39;s <code>isVisible</code> property, or one of its ancestor&#39;s <code>isVisible</code> property, changes to false and the associated element becomes hidden. Note that this hook is only reliable if all visibility is routed through the <code>isVisible</code> property.</li>
</ul>

<p>Apps can implement these hooks by defining a method by the hook&#39;s name on the view. Alternatively, it is possible to register a listener for the hook on a view:</p>
<div class="highlight javascript "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
</pre></td>
  <td class="code"><pre>view.on(<span class="string"><span class="delimiter">'</span><span class="content">willRerender</span><span class="delimiter">'</span></span>, <span class="keyword">function</span>() {
  <span class="comment">// do something with view</span>
});
</pre></td>
</tr></table>
</div></div><h4 class='anchorable-toc' id='toc_virtual-views'>Virtual Views</h4>
<p>As described above, Handlebars creates views in the view hierarchy to
represent bound values. Every time you use a Handlebars expression,
whether it&#39;s a simple value or a block helper like <code>{{#with}}</code> or
<code>{{#if}}</code>, Handlebars creates a new view.</p>

<p>Because Ember uses these views for internal bookkeeping only,
they are hidden from the view&#39;s public <code>parentView</code> and <code>childViews</code>
API. The public view hierarchy reflects only views created using the
<code>{{view}}</code> helper or through <code>ContainerView</code> (see below).</p>

<p>For example, consider the following Handlebars template:</p>
<div class="highlight handlebars "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
</pre></td>
  <td class="code"><pre><span class="tag">&lt;h1&gt;</span>Joe's Lamprey Shack<span class="tag">&lt;/h1&gt;</span>
<span class="inline"><span class="inline-delimiter">{{</span><span class="attribute-name">controller.restaurantHours</span><span class="inline-delimiter">}}</span></span>

<span class="inline"><span class="inline-delimiter">{{#</span><span class="attribute-name">view</span> <span class="attribute-name">App.FDAContactForm</span><span class="inline-delimiter">}}</span></span>
  If you are experiencing discomfort from eating at Joe's Lamprey Shack,
please use the form below to submit a complaint to the FDA.

  <span class="inline"><span class="inline-delimiter">{{#</span><span class="attribute-name">if</span> <span class="attribute-name">controller.allowComplaints</span><span class="inline-delimiter">}}</span></span>
    <span class="inline"><span class="inline-delimiter">{{</span><span class="attribute-name">view</span> <span class="attribute-name">Ember.TextArea</span> <span class="attribute-name">valueBinding</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">controller.complaint</span><span class="delimiter">&quot;</span></span><span class="inline-delimiter">}}</span></span>
    <span class="tag">&lt;button</span> <span class="inline"><span class="inline-delimiter">{{</span><span class="attribute-name">action</span> <span class="attribute-name">submitComplaint</span><span class="inline-delimiter">}}</span></span><span class="tag">&gt;</span>Submit<span class="tag">&lt;/button&gt;</span>
  <span class="inline"><span class="inline-delimiter">{{/</span><span class="attribute-name">if</span><span class="inline-delimiter">}}</span></span>
<span class="inline"><span class="inline-delimiter">{{/</span><span class="attribute-name">view</span><span class="inline-delimiter">}}</span></span>
</pre></td>
</tr></table>
</div></div>
<p>Rendering this template would create a hierarchy like this:</p>

<figure>
  <img src="/images/view-guide/public-view-hierarchy.png">
</figure>

<p>Behind the scenes, Ember tracks additional virtual views for the
Handlebars expressions:</p>

<figure>
  <img src="/images/view-guide/virtual-view-hierarchy.png">
</figure>

<p>From inside of the <code>TextArea</code>, the <code>parentView</code> would point to the
<code>FDAContactForm</code> and the <code>FDAContactForm</code>&#39;s <code>childViews</code> would be an
array of the single <code>TextArea</code> view.</p>

<p>You can see the internal view hierarchy by asking for the <code>_parentView</code>
or <code>_childViews</code>, which will include virtual views:</p>
<div class="highlight javascript "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> _childViews = view.get(<span class="string"><span class="delimiter">'</span><span class="content">_childViews</span><span class="delimiter">'</span></span>);
console.log(_childViews.objectAt(<span class="integer">0</span>).toString());
<span class="comment">//&gt; &lt;Ember._HandlebarsBoundView:ember1234&gt;</span>
</pre></td>
</tr></table>
</div></div>
<p><strong>Warning!</strong> You may not rely on these internal APIs in application code.
They may change at any time and have no public contract. The return
value may not be observable or bindable. It may not be an Ember object.
If you feel the need to use them, please contact us so we can expose a better 
public API for your use-case.</p>

<p>Bottom line: This API is like XML. If you think you have a use for it,
you may not yet understand the problem enough. Reconsider!</p>
<h4 class='anchorable-toc' id='toc_event-bubbling'>Event Bubbling</h4>
<p>One responsibility of views is to respond to primitive user events
and translate them into events that have semantic meaning for your
application.</p>

<p>For example, a delete button translates the primitive <code>click</code> event into
the application-specific &quot;remove this item from an array.&quot;</p>

<p>In order to respond to user events, create a new view subclass that
implements that event as a method:</p>
<div class="highlight javascript "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
4
5
6
</pre></td>
  <td class="code"><pre>App.DeleteButton = Ember.View.create({
  <span class="function">click</span>: <span class="keyword">function</span>(event) {
    <span class="keyword">var</span> item = <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">content</span><span class="delimiter">'</span></span>);
    <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">controller</span><span class="delimiter">'</span></span>).send(<span class="string"><span class="delimiter">'</span><span class="content">deleteItem</span><span class="delimiter">'</span></span>, item);
  }
});
</pre></td>
</tr></table>
</div></div>
<p>When you create a new <code>Ember.Application</code> instance, it registers an event
handler for each native browser event using jQuery&#39;s event delegation
API. When the user triggers an event, the application&#39;s event dispatcher
will find the view nearest to the event target that implements the
event.</p>

<p>A view implements an event by defining a method corresponding to the
event name. When the event name is made up of multiple words (like
<code>mouseup</code>) the method name should be the camelized form of the event
name (<code>mouseUp</code>).</p>

<p>Events will bubble up the view hierarchy until the event reaches the
root view. An event handler can stop propagation using the same
techniques as normal jQuery event handlers:</p>

<ul>
<li><code>return false</code> from the method</li>
<li><code>event.stopPropagation</code></li>
</ul>

<p>For example, imagine you defined the following view classes:</p>
<div class="highlight javascript "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
</pre></td>
  <td class="code"><pre>App.GrandparentView = Ember.View.extend({
  <span class="function">click</span>: <span class="keyword">function</span>() {
    console.log(<span class="string"><span class="delimiter">'</span><span class="content">Grandparent!</span><span class="delimiter">'</span></span>);
  }
});

App.ParentView = Ember.View.extend({
  <span class="function">click</span>: <span class="keyword">function</span>() {
    console.log(<span class="string"><span class="delimiter">'</span><span class="content">Parent!</span><span class="delimiter">'</span></span>);
    <span class="keyword">return</span> <span class="predefined-constant">false</span>;
  }
});

App.ChildView = Ember.View.extend({
  <span class="function">click</span>: <span class="keyword">function</span>() {
    console.log(<span class="string"><span class="delimiter">'</span><span class="content">Child!</span><span class="delimiter">'</span></span>);
  }
});
</pre></td>
</tr></table>
</div></div>
<p>And here&#39;s the Handlebars template that uses them:</p>
<div class="highlight handlebars "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="inline"><span class="inline-delimiter">{{#</span><span class="attribute-name">view</span> <span class="attribute-name">App.GrandparentView</span><span class="inline-delimiter">}}</span></span>
  <span class="inline"><span class="inline-delimiter">{{#</span><span class="attribute-name">view</span> <span class="attribute-name">App.ParentView</span><span class="inline-delimiter">}}</span></span>
    <span class="inline"><span class="inline-delimiter">{{#</span><span class="attribute-name">view</span> <span class="attribute-name">App.ChildView</span><span class="inline-delimiter">}}</span></span>
      <span class="tag">&lt;h1&gt;</span>Click me!<span class="tag">&lt;/h1&gt;</span>
    <span class="inline"><span class="inline-delimiter">{{/</span><span class="attribute-name">view</span><span class="inline-delimiter">}}</span></span>
  <span class="inline"><span class="inline-delimiter">{{/</span><span class="attribute-name">view</span><span class="inline-delimiter">}}</span></span>
<span class="inline"><span class="inline-delimiter">{{/</span><span class="attribute-name">view</span><span class="inline-delimiter">}}</span></span>
</pre></td>
</tr></table>
</div></div>
<p>If you clicked on the <code>&lt;h1&gt;</code>, you&#39;d see the following output in your
browser&#39;s console:</p>
<div class="highlight  "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
</pre></td>
  <td class="code"><pre>Child!
Parent!
</pre></td>
</tr></table>
</div></div>
<p>You can see that Ember invokes the handler on the child-most view that
received the event. The event continues to bubble to the <code>ParentView</code>,
but does not reach the <code>GrandparentView</code> because <code>ParentView</code> returns
false from its event handler.</p>

<p>You can use normal event bubbling techniques to implement familiar
patterns. For example, you could implement a <code>FormView</code> that defines a
<code>submit</code> method. Because the browser triggers the <code>submit</code> event when
the user hits enter in a text field, defining a <code>submit</code> method on the
form view will &quot;just work&quot;.</p>
<div class="highlight javascript "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
4
5
6
7
8
</pre></td>
  <td class="code"><pre>App.FormView = Ember.View.extend({
  <span class="key">tagName</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">form</span><span class="delimiter">&quot;</span></span>,

  <span class="function">submit</span>: <span class="keyword">function</span>(event) {
    <span class="comment">// will be invoked whenever the user triggers</span>
    <span class="comment">// the browser's `submit` method</span>
  }
});
</pre></td>
</tr></table>
</div></div><div class="highlight handlebars "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
4
5
</pre></td>
  <td class="code"><pre><span class="inline"><span class="inline-delimiter">{{#</span><span class="attribute-name">view</span> <span class="attribute-name">App.FormView</span><span class="inline-delimiter">}}</span></span>
  <span class="inline"><span class="inline-delimiter">{{</span><span class="attribute-name">view</span> <span class="attribute-name">Ember.TextField</span> <span class="attribute-name">valueBinding</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">controller.firstName</span><span class="delimiter">&quot;</span></span><span class="inline-delimiter">}}</span></span>
  <span class="inline"><span class="inline-delimiter">{{</span><span class="attribute-name">view</span> <span class="attribute-name">Ember.TextField</span> <span class="attribute-name">valueBinding</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">controller.lastName</span><span class="delimiter">&quot;</span></span><span class="inline-delimiter">}}</span></span>
  <span class="tag">&lt;button</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">submit</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>Done<span class="tag">&lt;/button&gt;</span>
<span class="inline"><span class="inline-delimiter">{{/</span><span class="attribute-name">view</span><span class="inline-delimiter">}}</span></span>
</pre></td>
</tr></table>
</div></div><h4 class='anchorable-toc' id='toc_adding-new-events'>Adding New Events</h4>
<p>Ember comes with built-in support for the following native browser
events:</p>

<table class="figure">
  <thead>
    <tr><th>Event Name</th><th>Method Name</th></tr>
  </thead>
  <tbody>
    <tr><td>touchstart</td><td>touchStart</td></tr>
    <tr><td>touchmove</td><td>touchMove</td></tr>
    <tr><td>touchend</td><td>touchEnd</td></tr>
    <tr><td>touchcancel</td><td>touchCancel</td></tr>
    <tr><td>keydown</td><td>keyDown</td></tr>
    <tr><td>keyup</td><td>keyUp</td></tr>
    <tr><td>keypress</td><td>keyPress</td></tr>
    <tr><td>mousedown</td><td>mouseDown</td></tr>
    <tr><td>mouseup</td><td>mouseUp</td></tr>
    <tr><td>contextmenu</td><td>contextMenu</td></tr>
    <tr><td>click</td><td>click</td></tr>
    <tr><td>dblclick</td><td>doubleClick</td></tr>
    <tr><td>mousemove</td><td>mouseMove</td></tr>
  </tbody>
</table>

<table class="figure">
  <thead>
    <tr><th>Event Name</th><th>Method Name</th></tr>
  </thead>
  <tbody>
    <tr><td>focusin</td><td>focusIn</td></tr>
    <tr><td>focusout</td><td>focusOut</td></tr>
    <tr><td>mouseenter</td><td>mouseEnter</td></tr>
    <tr><td>mouseleave</td><td>mouseLeave</td></tr>
    <tr><td>submit</td><td>submit</td></tr>
    <tr><td>change</td><td>change</td></tr>
    <tr><td>dragstart</td><td>dragStart</td></tr>
    <tr><td>drag</td><td>drag</td></tr>
    <tr><td>dragenter</td><td>dragEnter</td></tr>
    <tr><td>dragleave</td><td>dragLeave</td></tr>
    <tr><td>dragover</td><td>dragOver</td></tr>
    <tr><td>drop</td><td>drop</td></tr>
    <tr><td>dragend</td><td>dragEnd</td></tr>
  </tbody>
</table>

<p>You can add additional events to the event dispatcher when you create a
new application:</p>
<div class="highlight javascript "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre>App = Ember.Application.create({
  <span class="key">customEvents</span>: {
    <span class="comment">// add support for the loadedmetadata media</span>
    <span class="comment">// player event</span>
    <span class="key"><span class="delimiter">'</span><span class="content">loadedmetadata</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">loadedMetadata</span><span class="delimiter">&quot;</span></span>
  }
});
</pre></td>
</tr></table>
</div></div>
<p>In order for this to work for a custom event, the HTML5 spec must define
the event as &quot;bubbling&quot;, or jQuery must have provided an event
delegation shim for the event.</p>
<h3 class='anchorable-toc' id='toc_templated-views'>Templated Views</h3>
<p>As you&#39;ve seen so far in this guide, the majority of views that you will
use in your application are backed by a template. When using templates,
you do not need to programmatically create your view hierarchy because
the template creates it for you.</p>

<p>While rendering, the view&#39;s template can append views to its child views
array. Internally, the template&#39;s <code>{{view}}</code> helper calls the view&#39;s
<code>appendChild</code> method.</p>

<p>Calling <code>appendChild</code> does two things:</p>

<ol>
<li>Adds the child view to the <code>childViews</code> array.</li>
<li>Immediately renders the child view and adds it to the parent&#39;s render
buffer.</li>
</ol>

<figure>
  <img src="/images/view-guide/template-appendChild-interaction.png">
</figure>

<p>You may not call <code>appendChild</code> on a view after it has left the rendering
state. A template renders &quot;mixed content&quot; (both views and plain text) so
the parent view does not know exactly where to insert the new child view
once the rendering process has completed.</p>

<p>In the example above, imagine trying to insert a new view inside of
the parent view&#39;s <code>childViews</code> array. Should it go immediately
after the closing <code>&lt;/div&gt;</code> of <code>App.MyView</code>? Or should it go after the
closing <code>&lt;/div&gt;</code> of the entire view? There is no good answer that will
always be correct.</p>

<p>Because of this ambiguity, the only way to create a view hierarchy using
templates is via the <code>{{view}}</code> helper, which always inserts views
in the right place relative to any plain text.</p>

<p>While this works for most situations, occasionally you may want to have
direct, programmatic control of a view&#39;s children. In that case, you can
use <code>Ember.ContainerView</code>, which explicitly exposes a public API for
doing so.</p>
<h3 class='anchorable-toc' id='toc_container-views'>Container Views</h3>
<p>Container views contain no plain text. They are composed entirely of
their child views (which may themselves be template-backed).</p>

<p><code>ContainerView</code> exposes two public APIs for changing its contents:</p>

<ol>
<li>A writable <code>childViews</code> array into which you can insert <code>Ember.View</code>
instances.</li>
<li>A <code>currentView</code> property that, when set, inserts the new value into
the child views array. If there was a previous value of
<code>currentView</code>, it is removed from the <code>childViews</code> array.</li>
</ol>

<p>Here is an example of using the <code>childViews</code> API to create a view that
starts with a hypothetical <code>DescriptionView</code> and can add a new button at
any time by calling the <code>addButton</code> method:</p>
<div class="highlight javascript "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
16
17
18
</pre></td>
  <td class="code"><pre>App.ToolbarView = Ember.ContainerView.create({
  <span class="function">init</span>: <span class="keyword">function</span>() {
    <span class="keyword">var</span> childViews = <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">childViews</span><span class="delimiter">'</span></span>);
    <span class="keyword">var</span> descriptionView = App.DescriptionView.create();

    childViews.pushObject(descriptionView);
    <span class="local-variable">this</span>.addButton();

    <span class="keyword">return</span> <span class="local-variable">this</span>._super();
  },

  <span class="function">addButton</span>: <span class="keyword">function</span>() {
    <span class="keyword">var</span> childViews = <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">childViews</span><span class="delimiter">'</span></span>);
    <span class="keyword">var</span> button = Ember.ButtonView.create();

    childViews.pushObject(button);
  }
});
</pre></td>
</tr></table>
</div></div>
<p>As you can see in the example above, we initialize the <code>ContainerView</code>
with two views, and can add additional views during runtime. There is a
convenient shorthand for doing this view setup without having to
override the <code>init</code> method:</p>
<div class="highlight javascript "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
</pre></td>
  <td class="code"><pre>App.ToolbarView = Ember.ContainerView.create({
  <span class="key">childViews</span>: [<span class="string"><span class="delimiter">'</span><span class="content">descriptionView</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">buttonView</span><span class="delimiter">'</span></span>],

  <span class="key">descriptionView</span>: App.DescriptionView,
  <span class="key">buttonView</span>: Ember.ButtonView,

  <span class="function">addButton</span>: <span class="keyword">function</span>() {
    <span class="keyword">var</span> childViews = <span class="local-variable">this</span>.get(<span class="string"><span class="delimiter">'</span><span class="content">childViews</span><span class="delimiter">'</span></span>);
    <span class="keyword">var</span> button = Ember.ButtonView.create();

    childViews.pushObject(button);
  }
});
</pre></td>
</tr></table>
</div></div>
<p>As you can see above, when using this shorthand, you specify the
<code>childViews</code> as an array of strings. At initialization time, each of the
strings is used as a key to look up a view instance or class. That view
is automatically instantiated, if necessary, and added to the
<code>childViews</code> array.</p>

<figure>
  <img src="/images/view-guide/container-view-shorthand.png">
</figure>
<h3 class='anchorable-toc' id='toc_template-scopes'>Template Scopes</h3>
<p>Standard Handlebars templates have the concept of a <em>context</em>--the
object from which expressions will be looked up.</p>

<p>Some helpers, like <code>{{#with}}</code>, change the context inside their block.
Others, like <code>{{#if}}</code>, preserve the context. These are called
&quot;context-preserving helpers.&quot;</p>

<p>When a Handlebars template in an Ember app uses an expression
(<code>{{#if foo.bar}}</code>), Ember will automatically set up an
observer for that path on the current context.</p>

<p>If the object referenced by the path changes, Ember will automatically
re-render the block with the appropriate context. In the case of a
context-preserving helper, Ember will re-use the original context when
re-rendering the block. Otherwise, Ember will use the new value of the
path as the context.</p>
<div class="highlight handlebars "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
4
5
6
7
</pre></td>
  <td class="code"><pre><span class="inline"><span class="inline-delimiter">{{#</span><span class="attribute-name">if</span> <span class="attribute-name">controller.isAuthenticated</span><span class="inline-delimiter">}}</span></span>
  <span class="tag">&lt;h1&gt;</span>Welcome <span class="inline"><span class="inline-delimiter">{{</span><span class="attribute-name">controller.name</span><span class="inline-delimiter">}}</span></span><span class="tag">&lt;/h1&gt;</span>
<span class="inline"><span class="inline-delimiter">{{/</span><span class="attribute-name">if</span><span class="inline-delimiter">}}</span></span>

<span class="inline"><span class="inline-delimiter">{{#</span><span class="attribute-name">with</span> <span class="attribute-name">controller.user</span><span class="inline-delimiter">}}</span></span>
  <span class="tag">&lt;p&gt;</span>You have <span class="inline"><span class="inline-delimiter">{{</span><span class="attribute-name">notificationCount</span><span class="inline-delimiter">}}</span></span> notifications.<span class="tag">&lt;/p&gt;</span>
<span class="inline"><span class="inline-delimiter">{{/</span><span class="attribute-name">with</span><span class="inline-delimiter">}}</span></span>
</pre></td>
</tr></table>
</div></div>
<p>In the above template, when the <code>isAuthenticated</code> property changes from
false to true, Ember will render the block, using the original outer
scope as its context.</p>

<p>The <code>{{#with}}</code> helper changes the context of its block to the <code>user</code>
property on the current controller. When the <code>user</code> property changes,
Ember re-renders the block, using the new value of <code>controller.user</code> as
its context.</p>
<h4 class='anchorable-toc' id='toc_view-scope'>View Scope</h4>
<p>In addition to the Handlebars context, templates in Ember also have the
notion of the current view. No matter what the current context is, the
<code>view</code> property always references the closest view.</p>

<p>Note that the <code>view</code> property never references the internal views
created for block expressions like <code>{{#if}}</code>. This allows you to
differentiate between Handlebars contexts, which always work the way
they do in vanilla Handlebars, and the view hierarchy.</p>

<p>Because <code>view</code> points to an <code>Ember.View</code> instance, you can access any
properties on the view by using an expression like <code>view.propertyName</code>.
You can get access to a view&#39;s parent using <code>view.parentView</code>.</p>

<p>For example, imagine you had a view with the following properties:</p>
<div class="highlight javascript "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>App.MenuItemView = Ember.View.create({
  <span class="key">templateName</span>: <span class="string"><span class="delimiter">'</span><span class="content">menu_item_view</span><span class="delimiter">'</span></span>,
  <span class="key">bulletText</span>: <span class="string"><span class="delimiter">'</span><span class="content">*</span><span class="delimiter">'</span></span>
});
</pre></td>
</tr></table>
</div></div>
<p>…and the following template:</p>
<div class="highlight handlebars "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
</pre></td>
  <td class="code"><pre><span class="inline"><span class="inline-delimiter">{{#</span><span class="attribute-name">with</span> <span class="attribute-name">controller</span><span class="inline-delimiter">}}</span></span>
  <span class="inline"><span class="inline-delimiter">{{</span><span class="attribute-name">view.bulletText</span><span class="inline-delimiter">}}</span></span> <span class="inline"><span class="inline-delimiter">{{</span><span class="attribute-name">name</span><span class="inline-delimiter">}}</span></span>
<span class="inline"><span class="inline-delimiter">{{/</span><span class="attribute-name">with</span><span class="inline-delimiter">}}</span></span>
</pre></td>
</tr></table>
</div></div>
<p>Even though the Handlebars context has changed to the current
controller, you can still access the view&#39;s <code>bulletText</code> by referencing
<code>view.bulletText</code>.</p>
<h3 class='anchorable-toc' id='toc_template-variables'>Template Variables</h3>
<p>So far in this guide, we&#39;ve been handwaving around the use of the
<code>controller</code> property in our Handlebars templates. Where does it come
from?</p>

<p>Handlebars contexts in Ember can inherit variables from their parent
contexts. Before Ember looks up a variable in the current context, it
first checks in its template variables. As a template creates new
Handlebars scope, they automatically inherit the variables from their
parent scope.</p>

<p>Ember defines these <code>view</code> and <code>controller</code> variables, so they are
always found first when an expression uses the <code>view</code> or <code>controller</code>
names.</p>

<p>As described above, Ember sets the <code>view</code> variable on the Handlebars
context whenever a template uses the <code>{{#view}}</code> helper. Initially,
Ember sets the <code>view</code> variable to the view rendering the template.</p>

<p>Ember sets the <code>controller</code> variable on the Handlebars context whenever
a rendered view has a <code>controller</code> property. If a view has no
<code>controller</code> property, it inherits the <code>controller</code> variable from the
most recent view with one.</p>
<h4 class='anchorable-toc' id='toc_other-variables'>Other Variables</h4>
<p>Handlebars helpers in Ember may also specify variables. For example, the
<code>{{#with controller.person as tom}}</code> form specifies a <code>tom</code> variable
that descendent scopes can access. Even if a child context has a <code>tom</code>
property, the <code>tom</code> variable will supersede it.</p>

<p>This form has one major benefit: it allows you to shorten long paths
without losing access to the parent scope.</p>

<p>It is especially important in the <code>{{#each}}</code> helper, which provides
the <code>{{#each person in people}}</code> form.
In this form, descendent context have access to the <code>person</code> variable,
but remain in the same scope as where the template invoked the <code>each</code>.</p>
<div class="highlight handlebars "><div class="ribbon"></div><div class="scroller"><table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="inline"><span class="inline-delimiter">{{#</span><span class="attribute-name">with</span> <span class="attribute-name">controller.preferences</span><span class="inline-delimiter">}}</span></span>
  <span class="tag">&lt;h1&gt;</span>Title<span class="tag">&lt;/h1&gt;</span>
  <span class="tag">&lt;ul&gt;</span>
  <span class="inline"><span class="inline-delimiter">{{#</span><span class="attribute-name">each</span> <span class="attribute-name">person</span> <span class="attribute-name">in</span> <span class="attribute-name">controller.people</span><span class="inline-delimiter">}}</span></span>
    <span class="comment">{{! prefix here is controller.preferences.prefix }}</span>
    <span class="tag">&lt;li&gt;</span><span class="inline"><span class="inline-delimiter">{{</span><span class="attribute-name">prefix</span><span class="inline-delimiter">}}</span></span>: <span class="inline"><span class="inline-delimiter">{{</span><span class="attribute-name">person.fullName</span><span class="inline-delimiter">}}</span></span><span class="tag">&lt;/li&gt;</span>
  <span class="inline"><span class="inline-delimiter">{{/</span><span class="attribute-name">each</span><span class="inline-delimiter">}}</span></span>
  <span class="tag">&lt;ul&gt;</span>
<span class="inline"><span class="inline-delimiter">{{/</span><span class="attribute-name">with</span><span class="inline-delimiter">}}</span></span>
</pre></td>
</tr></table>
</div></div>
<p>Note that these variables inherit through <code>ContainerView</code>s, even though
they are not part of the Handlebars context hierarchy.</p>
<h4 class='anchorable-toc' id='toc_accessing-template-variables-from-views'>Accessing Template Variables from Views</h4>
<p>In most cases, you will need to access these template variables from
inside your templates. In some unusual cases, you may want to access the
variables in-scope from your view&#39;s JavaScript code.</p>

<p>You can do this by accessing the view&#39;s <code>templateVariables</code> property,
which will return a JavaScript object containing the variables that were
in scope when the view was rendered. <code>ContainerView</code>s also have access
to this property, which references the template variables in the most
recent template-backed view.</p>

<p>At present, you may not observe or bind a path containing
<code>templateVariables</code>.</p>

    
      <footer>
        
          <a class="previous-guide" href="/bilingual_guides/configuring-ember/disabling-prototype-extensions">
             ← Configuring Ember.js: Disabling Prototype Extensions
          </a>
         
        <a class="next-guide" href="/bilingual_guides/understanding-ember/managing-asynchrony">
          Managing Asynchrony →
        </a>
      
      </footer>
      
  </div>

  <script>
    $(function(){
      $("#toc-list .level-1 > a").click(function() {
        $(this).parent().find('> ol').slideToggle(function() {
          positionBackToTop(true);
        });

        return false;
      });

      $(function(){
        $('.anchorable-toc').each(function(){
          var toc = $(this),
          id = toc.attr('id'),
          href = "#" + id,
          anchor = '<a class="toc-anchor" href="'+href+'"></a>';

          toc.prepend(anchor);
        });
      });

    });
  </script>

      </div>
    </div>

    <div id="footer">
      <div id="footer-wrapper">
        <div class="info">&copy; 2013 Emberjs.CN <br/>Design by <a href="http://www.heropixel.com">HeroPixel</a></div>
        <div class="statement"><b>声明：</b>本站的文章可以随意在网上转载，但必须注明原文出处！</div>
      </div>
    </div>
  </body>
</html>
